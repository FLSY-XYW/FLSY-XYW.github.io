{"posts":[{"title":"C++Test","text":"插入图片测试","link":"/2024/11/01/C-Test/"},{"title":"CPP_LinearTable","text":"1. 线性表2. 线性表-数组数据结构定义 12345678910/** * LinearListArray 是一个使用数组实现的线性表结构。 * 该结构包含一个指向元素数组的指针和一个表示当前线性表长度的整数。 * 通过这种方式，可以方便地对线性表进行访问、插入和删除等操作。 */typedef struct LinearListArray{ ElempType *LinearLA; ///&lt; 指向动态分配的数组，用于存储线性表的元素 int length; ///&lt; 当前线性表的长度，即线性表中元素的数量} LLA; 初始化线性表 12345678910111213141516171819202122/** * 初始化线性列表（Linear List Array）并返回其指针 * * 本函数通过动态内存分配创建一个线性列表的数据结构，并将其初始化为空列表 * 首先，分配LLA结构体的空间，然后分配列表元素数组的空间，并初始化列表长度为0 * * @return {LLA *} 返回指向初始化后的LLA结构体的指针如果内存分配失败，返回NULL */LLA *InitializationLLA(){ // 分配LLA结构体空间 LLA *lla = (LLA *)malloc(sizeof(LLA)); // 分配列表元素数组空间 lla-&gt;LinearLA = (ElempType *)malloc(sizeof(ElempType) * MAXSIZE); // 初始化列表长度为0 lla-&gt;length = 0; // 返回指向初始化后的LLA结构体的指针 return lla;} 在线性列表的指定位置插入元素 12345678910111213141516171819202122232425262728293031323334353637383940/** * 在线性列表的指定位置插入元素 * * 该函数旨在向线性列表(lla)中，在指定的位置插入一个新元素e。函数首先检查线性列表是否已满， * 其次检查插入位置是否有效。如果检查通过，则通过移动元素为新元素腾出空间，并插入新元素， * 最后增加线性列表的长度计数。 * * @param lla 指向线性列表的指针。假定线性列表已初始化且不为空。 * @param position 插入位置。基于1的索引，即第一个元素的位置为1。 * @param e 待插入的元素。 * @return 返回1表示插入操作成功，返回0表示插入操作失败（由于列表满或插入位置无效）。 */int InsertLLA(LLA *lla, int position, ElempType e){ // 检查线性表是否已满 if (lla-&gt;length &gt;= MAXSIZE) { cout &lt;&lt; &quot;线性表已经满了&quot; &lt;&lt; endl; return 0; } // 检查插入位置是否有效 if (position &lt; 1 || position &gt; lla-&gt;length) { cout &lt;&lt; &quot;插入位置错误&quot; &lt;&lt; endl; return 0; } // 为新元素腾出空间 if (position &lt;= lla-&gt;length) { for (int i = lla-&gt;length - 1; i &gt;= position - 1; i--) { lla-&gt;LinearLA[i + 1] = lla-&gt;LinearLA[i]; } } // 插入新元素 lla-&gt;LinearLA[position - 1] = e; // 更新线性表长度 lla-&gt;length += 1; return 1;} 假设该线性表为int lla = {1, 2, 3, 4, 5};，想要在3号位插入数据（基于索引1，这里是自定义位置，并不是数组的索引），也就是在数据3的位置插入数据，那么就需要把数据3、4、5向后移动，此时查看函数实现，lla-&gt;length决定了线性表的边界，lla-&gt;length - 1决定了线性表的索引最大值，position - 1决定了要向后移动的数据的起始位置，完成数据移动，在预定的位置插入数据。 在线性表尾部插入数据 1234567891011121314151617181920212223/** * 向线性表-数组添加数据(尾部添加) * * @param lla 线性表结构的指针 * @param e 要添加的元素 * @return 添加成功返回1，否则返回0 * * 此函数检查线性表是否已满，如果未满，则将元素e添加到线性表的末尾，并增加线性表的长度 */int AppendLLA(LLA *lla, ElempType e){ // 检查线性表是否已满 if (lla-&gt;length &gt;= MAXSIZE) { cout &lt;&lt; &quot;线性表已经满了&quot; &lt;&lt; endl; return 0; } // 将元素e添加到线性表的末尾 lla-&gt;LinearLA[lla-&gt;length] = e; // 增加线性表的长度 lla-&gt;length += 1; return 1;} 数组的索引开始数是0，而线性表的长度是从1开始计算，所以lla-&gt;length就是尾部最新位置的的索引（假设数组有100条数据，数据索引就是0~99，数组长度就是100，因此length就是追加数组尾部的索引 ） 删除线性表指定位置的数据 1234567891011121314151617181920212223242526272829303132333435363738/** * 删除线性表中的指定位置的元素 * * @param lla 指向线性表的指针 * @param position 要删除的元素的位置 * @return 返回删除操作的结果，-1表示表为空，0表示删除位置错误，1表示删除成功 */int DeleteLLA(LLA *lla, int position){ // 检查线性表是否为空，如果为空，则输出提示信息并返回-1 if (lla-&gt;length == 0) { cout &lt;&lt; &quot;空表&quot; &lt;&lt; endl; return -1; } // 检查删除位置是否有效，如果无效，则输出提示信息并返回0 if (position &lt; 1 || position &gt; lla-&gt;length) { cout &lt;&lt; &quot;删除位置错误&quot; &lt;&lt; endl; return 0; } // 如果删除位置有效，则将该位置之后的所有元素向前移动一位 if (position &lt;= lla-&gt;length) { for (int i = position - 1; i &lt; lla-&gt;length - 1; i++) { lla-&gt;LinearLA[i] = lla-&gt;LinearLA[i + 1]; } } // 更新线性表的长度 lla-&gt;length -= 1; // 返回删除成功的标志 return 1;} 根据位置查找线性表中的元素 123456789101112131415161718192021/** * 根据位置查找线性列表中的元素 * * 此函数旨在通过指定的位置来获取线性列表（LLA）中的元素如果位置超出列表长度， * 则输出错误信息并返回特殊值 * * @param lla 指向线性列表的指针，该列表包含元素和长度信息 * @param position 指定的元素位置，位置从1开始 * @return 如果位置有效，返回指定位置的元素值；如果位置超出列表长度，返回-1 */ElempType FindLLAByPosition(LLA *lla, int position){ // 检查位置是否超出列表长度 if (position &gt;= lla-&gt;length) { cout &lt;&lt; &quot;越界了！！！&quot; &lt;&lt; endl; return -1; } // 返回指定位置的元素值 return lla-&gt;LinearLA[position - 1];} 在线性表中查找指定数据的位置 12345678910111213141516171819202122232425/** * 在线性列表中查找特定元素的位置 * * @param lla 指向线性列表的指针 * @param e 要查找的元素 * @return 如果找到元素，返回元素在列表中的位置（位置从1开始计数）；如果未找到，返回0 * * 此函数通过遍历线性列表来查找指定元素的位置它假设列表中的元素是唯一的 * 如果列表为空或者元素不在列表中，函数将返回0这个设计选择是为了提供一种简单的方法来判断元素是否存在 * 注意：这个函数依赖于外部定义的线性列表结构和元素类型 */int FindLLAByData(LLA *lla, ElempType e){ // 遍历线性列表，寻找匹配的元素 for (int i = 0; i &lt; lla-&gt;length; i++) { // 当找到匹配的元素时，返回其位置（位置从1开始计数） if (lla-&gt;LinearLA[i] == e) { return i + 1; } } // 如果未找到匹配的元素，返回0 return 0;} 遍历并打印线性表 123456789101112131415161718/** * TraversalLLA函数用于遍历并打印线性列表LLA的元素 * @param lla 指向LLA结构的指针，LLA结构包含线性列表的长度和元素数组 * * 此函数通过循环遍历线性列表的每个元素，并将其打印到标准输出中 * 每个元素后面跟随一个空格，所有元素打印完毕后，输出一个换行符 */void TraversalLLA(LLA *lla){ // 遍历线性列表的每个元素 for (int i = 0; i &lt; lla-&gt;length; i++) { // 打印当前元素的值，后面跟随一个空格 cout &lt;&lt; lla-&gt;LinearLA[i] &lt;&lt; &quot; &quot;; } // 所有元素打印完毕后，输出一个换行符 cout &lt;&lt; endl;} 3. 线性表 -链表","link":"/2024/11/16/CPP-LinearTable/"},{"title":"C++Test2","text":"C++基础学习2 这是一个测试文件对于在cpp文件内同时使用iostream头文件和string头文件的一些思考 iostream头文件间接引用了string文件，如果没有额外声明string头文件，仍然可以使用string类型。","link":"/2024/10/31/C-Test2/"},{"title":"Get请求与Post请求","text":"GET请求： 通常用于请求服务器发送特定资源。 数据被附加在URL之后，以查询字符串的形式发送。 GET请求可以被缓存，也可以保留在浏览器的历史记录中。 GET请求有长度限制，因为它依赖于URL的长度。 通常用于获取数据，而不是提交数据。 POST请求： 用于向服务器提交数据进行处理，例如，提交表单数据。 数据被包含在请求体中，不显示在URL中。 POST请求不会被缓存，也不会保留在浏览器的历史记录中。 POST请求理论上没有长度限制，可以发送大量的数据。 通常用于创建或更新资源。 一、是什么GET和POST，两者是HTTP协议中发送请求的方法 GETGET方法请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据 POSTPOST方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用 本质上都是TCP链接，并无差别 但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中会体现出一些区别 二、区别从w3schools得到的标准答案的区别如下： GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST没有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中 参数位置貌似从上面看到GET与POST请求区别非常大，但两者实质并没有区别 无论 GET 还是 POST，用的都是同一个传输层协议，所以在传输上没有区别 当不携带参数的时候，两者最大的区别为第一行方法名不同 POST /uri HTTP/1.1 \\r\\n GET /uri HTTP/1.1 \\r\\n 当携带参数的时候，我们都知道GET请求是放在url中，POST则放在body中 GET 方法简约版报文是这样的 12GET /index.html?name=qiming.c&amp;age=22 HTTP/1.1Host: localhost POST 方法简约版报文是这样的 12345POST /index.html HTTP/1.1Host: localhostContent-Type: application/x-www-form-urlencodedname=qiming.c&amp;age=22 注意：这里只是约定，并不属于HTTP规范，相反的，我们可以在POST请求中url中写入参数，或者GET请求中的body携带参数 参数长度HTTP 协议没有Body和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持 这里限制的是整个URL长度，而不仅仅是参数值的长度 服务器处理长 URL 要消耗比较多的资源，为了性能和安全考虑，会给 URL 长度加限制 安全POST 比 GET 安全，因为数据在地址栏上不可见 然而，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文 只有使用HTTPS才能加密安全 数据包对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据） 对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次","link":"/2024/11/02/Get%E8%AF%B7%E6%B1%82%E4%B8%8EPost%E8%AF%B7%E6%B1%82/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/10/30/hello-world/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"CPP","slug":"CPP","link":"/tags/CPP/"},{"name":"CPP DATA STRUCT","slug":"CPP-DATA-STRUCT","link":"/tags/CPP-DATA-STRUCT/"},{"name":"HTTP请求","slug":"HTTP请求","link":"/tags/HTTP%E8%AF%B7%E6%B1%82/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"categories":[{"name":"CPP基础学习测试","slug":"CPP基础学习测试","link":"/categories/CPP%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B5%8B%E8%AF%95/"},{"name":"CPP数据结构","slug":"CPP数据结构","link":"/categories/CPP%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Web开发","slug":"Web开发","link":"/categories/Web%E5%BC%80%E5%8F%91/"}],"pages":[]}